/**
 * @file main.c
 * @author Joey Hughes
 * Main file for the grey codes program. Runs checks and determines number of grey codes with a certain number of digits
*/

#include <stdlib.h>
#include <stdbool.h>
#include <stdio.h>
#include <string.h>
#include <time.h>
#include <pthread.h>

/** This defines the macro of how many digits for the grey code search by default to be 4. Should usually be set in compilation with -DNUM_DIGITS=X */
#ifndef NUM_DIGITS
#define NUM_DIGITS 4
#endif

/** This calculates the length of the sequence of steps for each code at compile time and stores it in len. */
#define len (1 << NUM_DIGITS)

/* This is how many step values, from 0 up, to skip and not make threads for. */
#define skippedThreads 1

/* The value of a step that changes the highest order bit. */
#define LAST_DIGIT_STEP (1 << (NUM_DIGITS - 1))

/** This macro generates an output file name based on the parameter. */
#define FILENAME(x) #x "Digits_0102.bin"

/** This calls the other output filename macro, such that NUM_DIGITS can be passed as a parameter into this and the value of how many digits is used as the parameter for FILENAME. */
#define OUTFILE(x) FILENAME(x)

/** 16 for xDigits_0102.txt, one for the null terminator. Note that this assumes the number of digits is less than 10. */
#define OUTFILE_NAME_LENGTH 17

/** This is the index of the character in the outfile name string that corresponds to the N, which is changed by each thread. */
#define OUTFILE_NAME_THREAD_NUM_INDEX 8

/** This macro does the log base 2 of the given number. Used to go from the step representation to the digit number representation. */
#define log2(x) ((int)(sizeof(x) * 8) - 1 - __builtin_clz(x))

/** This defines a short name for each step's XOR mask. Essentialy this holds which digit is being changed at the current step. */
typedef unsigned int step;

/** This global variable is generated and written to in main and used by each of the threads so they don't have to all compute it again. */
step lowest[len];




/**
 * This function calculates the count of how many grey codes begin with a given start step number. This is used
 * as the function ran by several threads. The parameter is a void pointer that initially points to the step number 
 * to start at, but at the end is used to return the final count for this digit.
*/
void *calculateCodesWithSetStart(void *threadVal)
{
    // Dereference the threadVal immediately, I'm not sure if there might be issues with multiple threads accessing a pointer to a similar location,
    // but this might alleviate that if that were the case.
    int startStepValue = *(int *)threadVal;

    int count        = 0;               // The count variable of how many grey codes have been found.
    step test[len]   = {};              // The step array. This holds steps, which are unsigned characters, that represent which binary digit is being switched during that step.
    step *sptr       = test;            // Pointer to a step within the test array. Used for looping through
    int bffr[len+1];                    // This is the buffer that holds the values generated by actually performing the grey code sequence for testing it.
    int *buf         = bffr + 1;        // Pointer to the "start" of the grey code. Since the first 0 never changes, but is used when calculating values, we start the pointer one val in.
    int *bptr        = buf;             // Pointer to within the buffer. Used for looping through.
    int *bufEndPtr   = buf + len - 1;   // Points to the ending 0 in valid grey codes.
    bool flags[len]  = {};              // This keeps track of if a number (the number of the index) has been reached in the sequence yet or not
    step *limitStep = test + 3;         // This is which step is being limited, as in when it changes then this thread is done and returns its count. CHANGED

    // The first value of the buffer is an unchanging 0
    bffr[0] = 0;

    // Initialize the test to the start digit, then the lowest array after that
    test[0] = 1;
    test[1] = 2; // CHANGED
    test[2] = 1; // CHANGED
    test[3] = startStepValue; // CHANGED
    memcpy(test + 4, lowest, (len - 4) * sizeof(step)); // CHANGED

    // This generates the output file based on how many digits and which thread this is. Each thread outputs to a different file.
    char outfileName[OUTFILE_NAME_LENGTH] = OUTFILE(NUM_DIGITS);
    FILE *out = fopen(outfileName, "wb");
    if(out == NULL) { // If there was a problem getting the output file, return -1 and exit.
        printf("In the thread with first step %d, there was an issue opening the output file. Exiting.\n", log2(startStepValue));
        *(int *)threadVal = -1;
        pthread_exit(NULL);
        return NULL;
    }
    
    // Loop until the first two digits of the grey code are the same. There will be no more valid grey codes once that happens.
    while(*limitStep == startStepValue) {

        // -- Checking if it is a valid grey code sequence.
        // For every changed value in the steps, until reaching a 0.
        while(true) {
            // Calculate the next number in the sequence.
            *bptr = *(bptr - 1) ^ (*sptr);

            // If it has reached 0, before the end: invalid, at the end: valid.
            if(!*bptr) {
                if(bptr < bufEndPtr) goto increment; else break; // If before the end, invalid, otherwise, valid.
            }

            // Check if this number has already been reached.
            if(flags[*bptr]) goto increment;

            // If it has passed all that, it's valid
            flags[*bptr] = true;

            // Go to the next step
            sptr++;
            bptr++;
        }

        // 0 has been reached, there were no duplicates and it's the right length, so we have reached a valid grey code
        count++;
        
        // Output to file
        //fwrite(test, sizeof(step), len, out); // This outputs the full test array as XOR masks (powers of 2)
        for(int j = 0; j < len; j++) fputc(log2(test[j]), out); // This outputs the test array as bytes of digit numbers (not just powers of 2).
        //for(int j = 0; j < len; j++) printf(j != len - 1 ? "%x," : "%x\n", log2(test[j]));
        
        // We increment the sequence now from the very end.
        if((*sptr) & LAST_DIGIT_STEP) { // If the last is the max step, increment back. (There won't be two max in a row, that would make the sequence invalid, so no loop.)
            *(sptr--) = 1;
            flags[*(bptr--)] = false;
        }
        (*sptr) <<= 1;
        flags[*(bptr)] = false;
        continue;


        increment:
        // -- We have encountered an invalid sequence.
        // Increment from the invalid step that needs to be changed.
        while((*sptr) & LAST_DIGIT_STEP) {
            sptr--;
            flags[*(--bptr)] = false;
        }
        (*sptr) <<= 1;

        // If we have incremented it to the same as the previous, increment it again.
        if(*sptr == *(sptr - 1)) goto increment;

        // Copy from lowest to the rest of the steps after the last incremented one.
        memcpy(sptr + 1, lowest, (len - 1 - (sptr - test)) * sizeof(step));
    }

    // // Print the final statistics
    // printf(" ----- In total the num found was %d with %d digits, first step: %d.\n\n", count, NUM_DIGITS, log2(startStepValue));

    // Write the count to the thread value
    *(int *)threadVal = count;

    // Exit the thread
    //pthread_exit(NULL); CHANGED
    return NULL;
}



/**
 * Starts the program.
 * @return Exit status.
*/
int main() 
{
    // Print opening empty line
    printf("\n");

    #ifdef RUNTIME
    // Get starting benchmark time
    clock_t start_time = clock();
    #endif

    // First, calculate the "lowest" grey code, the 01020103...
    lowest[0] = 1;
    step *init = lowest + 1;
    for(int i = 0; i < NUM_DIGITS; i++) {

        // Copy the previous block over
        memcpy(init, lowest, (init - lowest) * sizeof(step));

        // Move forward almost to the end
        init += init - lowest - 1;

        // Increment the last number and move to the end
        *init <<= 1;
        init++;
    }
    lowest[len - 1] >>= 1; // The last number will be over, so decrement it to get the the "first" grey code.

    /* 
    This will create threads which pass in possible step values.
    The skippedThreads value will skip passing in that number of steps and reduce the number of threads.
    In particular, under the unproven but suspected assumption that each starting step number will always have the same number of grey codes, we fix the first step to 0
        and count all the grey codes, in different threads, for 00, 01, 02, 03, etc. However, we know 00 will never work, so we skip one thread. This means the thread
        that would count codes starting with 00 will never be made. There are other situations where you may want to also skip 1 as well, and in that case you
        could set it to 2, so it wouldn't make threads with the parameter of 0 or 1 (actually binary 1 and 10, but representing changing digits 0 and 1.), and so on.
    Since this program just wants to count the total, just one is skipped.
    */

    // // Array of the thread ids
    // pthread_t threadIds[NUM_DIGITS];

    // // Array of all the initial steps
    // int threadVals[NUM_DIGITS];

    // // Create all the initial step values that will be used
    // for(int i = skippedThreads; i < NUM_DIGITS; i++) threadVals[i] = (1 << i);

    // // Generate the threads and pass in the value.
    // for(int i = skippedThreads; i < NUM_DIGITS; i++) {
    //     pthread_create(threadIds + i, NULL, &calculateCodesWithSetStart, (void *)(threadVals + i));
    // }

    // // Wait for all the threads and add up their totals.
    int totalCount = 4; // CHANGED
    // for(int i = skippedThreads; i < NUM_DIGITS; i++) {
    //     pthread_join(threadIds[i], NULL);
    //     totalCount += threadVals[i];
    // }

    calculateCodesWithSetStart((void *)&totalCount); // CHANGED

    // Print the results.
    printf(" ---------- The num of codes starting with 0102 is: %d\n", totalCount);
    printf(" ---------- They have been outputted to \"%dDigits_0102.bin\".\n", NUM_DIGITS);
    

    #ifdef RUNTIME
    // Get end benchmarking time
    clock_t end_time = clock();
    printf("-- This run took %f seconds.\n", ((double) (end_time - start_time)) / CLOCKS_PER_SEC );
    #endif

    pthread_exit(NULL);
    return EXIT_SUCCESS;
}

/*
This is a note for this code to pring progress since I want to clean up the function code for now but also I will probably use this later for debugging or optimization
// Print progress to terminal
//if((count & 0x3FFFF) == 0) {
//     printf("Code %9d found: ", count); // Print progress to console
//     for(int j = 0; j < len; j++) printf(j != len - 1 ? "%x," : "%x\n", test[j]);
// }

// Output code to output file
//for(int j = 0; j < len; j++) fprintf(out, j != len - 1 ? "%x," : "%x\n", test[j]);
*/


