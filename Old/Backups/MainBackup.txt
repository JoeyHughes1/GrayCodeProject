This is before I changed the buffer

/**
 * @file main.c
 * @author Joey Hughes
 * Main file for the grey codes program. Runs checks and determines number of grey codes with a certain number of digits
*/

#include <stdlib.h>
#include <stdbool.h>
#include <stdio.h>
#include <string.h>
#include <time.h>
#include <pthread.h>

/** This defines the macro of how many digits for the grey code search by default to be 4. Should usually be set in compilation with -DNUM_DIGITS=X */
#ifndef NUM_DIGITS
#define NUM_DIGITS 4
#endif

/** This calculates the length of the sequence of steps for each code at compile time and stores it in len. */
#define len (1 << NUM_DIGITS)

#define LAST_DIGIT_STEP (1 << (NUM_DIGITS - 1))

/** This macro generates an output file name based on the parameter. */
#define FILENAME(x) #x "Digits.txt"

/** This calls the other output filename macro, such that NUM_DIGITS can be passed as a parameter into this and the value of how many digits is used as the parameter for FILENAME. */
#define OUTFILE(x) FILENAME(x)


/** This defines a short name for a simple byte that stores which digit is being changed in this step. */
typedef unsigned int step;


/** This global variable is generated and written to in main and used by each of the threads so they don't have to all compute it again. */
step lowest[len];



/**
 * This function calculates the count of how many grey codes begin with a given start step number. This is used
 * as the function ran by several threads. The parameter is a void pointer that initially points to the step number 
 * to start at, but at the end is used to return the final count for this digit.
*/
void *calculateCodesWithSetStart(void *threadVal)
{
    // Dereference the threadVal immediately, I'm not sure if there might be issues with multiple threads accessing a pointer to a similar location,
    // but this might alleviate that if that were the case.
    int startStepValue = *(int *)threadVal;

    int count        = 0;               // The count variable of how many grey codes have been found.
    step test[len]   = {};              // The step array. This holds steps, which are unsigned characters, that represent which binary digit is being switched during that step.
    step *endPtr     = test + len - 1;  // The pointer to the end of the test array. Unchanged, this variable just stores this value since it's used a lot.
    step *incPtr     = test;            // Pointer to a step within the test array specifically for incrementing. The location of this informs of where to start updating the buffer the next loop.
    step *sptr;                         // Pointer to a step within the test array. Used for looping through
    int bffr[len+1];                    // This is the buffer that holds the values generated by actually performing the grey code sequence for testing it.
    int *buf         = bffr + 1;        // Pointer to the "start" of the grey code. Since the first 0 never changes, but is used when calculating values, we start the pointer one val in.
    int *bptr;                          // Pointer to within the buffer. Used for looping through.
    int *checkptr;                      // Another pointer to within the buffer used to search back through the buffer to find duplicate values.
    int *bufEndPtr   = buf + len - 1;   // Points to the ending 0 in valid grey codes.
    register int bufIdx       = 0;               // Essentially how far into the buffer the calculation currently is.
    int checkIdx     = 0;               // Used as a counter for the checking for loop when looking back for duplicates
    // int debugCount = 0;
    // The first value of the buffer is an unchanging 0
    bffr[0] = 0;

    // Initialize the test to the start digit, then the lowest array after that
    if(startStepValue == 1) memcpy(test, lowest, len * sizeof(step)); else {
        test[0] = startStepValue;
        memcpy(test + 1, lowest, (len - 1) * sizeof(step));
    }
    
    // Loop until the first two digits of the grey code are the same. There will be no more valid grey codes once that happens.
    //while(!(test[0] == NUM_DIGITS - 1 && test[1] == NUM_DIGITS - 1)) {
    while(count < 655360) {
    //while(*test == startStepValue) {
        // printf("Back at the top: ");
        // -- Checking if it is a valid grey code sequence.
        // Start the pointers in buffer and step at the point where it has changed since the last loop.
        bufIdx = incPtr - test;
        bptr = buf + bufIdx;
        sptr = test + bufIdx;

        // For every changed value in the buffer
        do {
            // Calculate the next number in the sequence.
            bufIdx++;
            checkptr = bptr - 1;
            *bptr = (*checkptr) ^ (*sptr);

            // If it has reached 0 before the end of the sequence, it's invalid.
            if(!*bptr && bptr < bufEndPtr) goto increment;

            // Go back through all previous numbers in the buffer. If the current num is a match with any of the previous, there's a duplicate, not valid.
            checkIdx = bufIdx;
            while(--checkIdx) if(*bptr == *(checkptr--)) goto increment;

            // Go to the next step
            sptr++;
            bptr++;
        } while((bufIdx) < len);

        // The buffer is now filled with the generated numbers from the grey code. Check the end is 0.
        //     If not, it's not cyclical, and for now I only want cyclical
        //     If it is, increment the count
        if(!*bufEndPtr) {
            // printf("Valid.\n\n");
            count++;
        }
        
        // If we are here, it was a valid grey code, cyclical or not. 
        //     Either way, it was valid until the end, so increment from the end and continue.
        incPtr = endPtr;
        while((*incPtr) & LAST_DIGIT_STEP) *(incPtr--) = 1;
        (*incPtr) <<= 1;
        continue;


        increment:
        // -- We have encountered an invalid sequence.
        // printf("Invalid: ");
        // for(int j = 0; j < len; j++) printf(j != len - 1 ? "%x," : "%x\n", test[j]);
        // First, copy lowest to the rest of the steps.
        

        // Then, we increment from the invalid step that needs to be changed.
        incPtr = sptr;
        while((*incPtr) & LAST_DIGIT_STEP) *(incPtr--) = 1;
        (*incPtr) <<= 1;

        // printf(" became: ");
        // for(int j = 0; j < len; j++) printf(j != len - 1 ? "%x," : "%x\n", test[j]);

        if(*incPtr == *(incPtr - 1)) { 
            //debugCount++;
            // printf("[%d]%d == %d, back again... ", (int)(incPtr - test), *incPtr, *(incPtr - 1));
            sptr = incPtr;
            goto increment;
        }
        // if(*sptr == 1 && sptr < endPtr) {
        //     sptr--;
        //     goto increment;
        // }
        memcpy(sptr + 1, lowest, (len - bufIdx) * sizeof(step));
    }

    // Print the final statistics
    printf(" ----- In total the num found was %d with %d digits, first step: %d.\n\n", count, NUM_DIGITS, startStepValue);
    // printf("sduifbsduib %d", debugCount);
    // Write the count to the thread value
    *(int *)threadVal = count;

    // Exit the thread
    pthread_exit(NULL);
    return NULL;
}



/**
 * Starts the program.
 * @return Exit status.
*/
int main() 
{
    #ifdef RUNTIME
    // Get starting benchmark time
    clock_t start_time = clock();
    #endif

    // First, calculate the "lowest" grey code, the 01020103...
    lowest[0] = 1;
    step *init = lowest + 1;
    for(int i = 0; i < NUM_DIGITS; i++) {

        // Copy the previous block over
        memcpy(init, lowest, (init - lowest) * sizeof(step));

        // Move forward almost to the end
        init += init - lowest - 1;

        // Increment the last number and move to the end
        *init <<= 1;
        init++;
    }
    lowest[len - 1] >>= 1; // The last number will be over, so decrement it to get the the "first" grey code.


    // Array of the thread ids
    pthread_t threadIds[NUM_DIGITS];

    // Array of all the numbers
    int threadVals[NUM_DIGITS];
    for(int i = 0; i < NUM_DIGITS; i++) threadVals[i] = (1 << i);

    // Generate the threads
    for(int i = 0; i < 1; i++) {
        pthread_create(threadIds + i, NULL, &calculateCodesWithSetStart, (void *)(threadVals + i));
    }

    // Wait for all the threads
    int totalCount = 0;
    for(int i = 0; i < 1; i++) {
        pthread_join(threadIds[i], NULL);
        totalCount += threadVals[i];
    }

    // Print the result
    printf(" ---------- The grand total for all digits is: %d\n", totalCount);
    

    #ifdef RUNTIME
    // Get end benchmarking time
    clock_t end_time = clock();
    printf("-- This run took %f seconds.\n", ((double) (end_time - start_time)) / CLOCKS_PER_SEC );
    #endif

    pthread_exit(NULL);
    return EXIT_SUCCESS;
}

/*
This is a note for this code to pring progress since I want to clean up the function code for now but also I will probably use this later for debugging or optimization
// Print progress to terminal
//if((count & 0x3FFFF) == 0) {
//     printf("Code %9d found: ", count); // Print progress to console
//     for(int j = 0; j < len; j++) printf(j != len - 1 ? "%x," : "%x\n", test[j]);
// }

// Output code to output file
//for(int j = 0; j < len; j++) fprintf(out, j != len - 1 ? "%x," : "%x\n", test[j]);
*/


